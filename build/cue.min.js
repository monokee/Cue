const e=window.localStorage,t=new Map,n={fetch:(t,n=86400,o)=>new Promise((s,i)=>{const a=function(t){const n=e.getItem(`${t}::ts`);return null===n?null:n<Date.now()?(e.removeItem(t),e.removeItem(`${t}::ts`),null):e.getItem(t)}(t);null!==a?s(JSON.parse(a)):r(t,"GET",o).then(r=>{!function(t,n,r){const o=Date.now()+1e3*r;"object"==typeof n&&(n=JSON.stringify(n));e.setItem(t,n),e.setItem(`${t}::ts`,o)}(t,r,n),s(JSON.parse(r))}).catch(e=>{i(e)})}),post:(e,t,n)=>new Promise((o,s)=>{r(e,"POST",n,t).then(e=>o(JSON.parse(e))).catch(e=>s(e))})};function r(e,n,r,o={}){if(t.has(e))return t.get(e);{const s={"Content-Type":"application/json"};r&&(s.Authorization=`Bearer ${r}`);const i=new Promise((r,a)=>{t.set(e,i);fetch(e,{method:n,mode:"cors",cache:"no-cache",credentials:"same-origin",headers:s,redirect:"follow",referrer:"no-referrer",body:"GET"===n?null:JSON.stringify(o)}).then(n=>{n.json().then(n=>{t.delete(e),r(n)})}).catch(n=>{t.delete(e),a(n)})});return i}}const o=()=>{};function s(e,t){return Array.isArray(e)?!(!Array.isArray(t)||e.length!==t.length)&&function(e,t){for(let n=0;n<e.length;n++)if(!s(e[n],t[n]))return!1;return!0}(e,t):"object"==typeof e?"object"==typeof t&&(null!==e&&null!==t||e===t)&&function(e,t){const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(let o,i=0;i<n.length;i++)if(o=n[i],-1===r.indexOf(o)||!s(e[o],t[r[i]]))return!1;return!0}(e,t):e===t}function i(e){return"function"==typeof e?e:o}function a(e){const t={},n=Object.keys(e);for(let r,o,s=0;s<n.length;s++)o=e[r=n[s]],t[r]=o?Array.isArray(o)?l(o):"object"==typeof o?a(o):o:o;return t}function l(e){const t=[];for(let n,r=0;r<e.length;r++)n=e[r],t[r]=n?Array.isArray(n)?l(n):"object"==typeof n?a(n):n:n;return t}const c=new Map,u=window.localStorage,h="VCS::PARSE::",f=h.length,d="VCS::ALL_KEYS",p={get(e){if(!e){const e={},t=u.getItem(d);if(null!==t){const n=t.split(",");for(let t=0;t<n.length;t++){const r=u.getItem(`VCS::${n[t]}`);e[n[t]]=g(r)?JSON.parse(r.substring(f)):r}}return e}const t=e.split("/"),n=u.getItem(`VCS::${t[0]}`);if(null===n)return null;if(!g(n))return n;const r=JSON.parse(n.substring(f));if(t.length>1){const[e,n]=y(r,t);return e[n]}return r},set(e,t){if(1===arguments.length){if("object"!=typeof e||null===e)throw new Error("Invalid arguments provided to Store.set...");this.clear(!0);for(const t in e)this.set(t,e[t]);return!0}const n=e.split("/"),r=`VCS::${n[0]}`,o=u.getItem(r);if(n.length>1){if(g(o)){const i=JSON.parse(o.substring(f)),[a,l]=y(i,n);return!s(a[l],t)&&(a[l]=t,u.setItem(r,`${h}${JSON.stringify(i,m)}`),b(e,t,n,i),!0)}throw new Error(`Cannot set property at path: "${e}" because the current value is stored as a string.`)}if(null===o){"string"==typeof t?u.setItem(r,t):u.setItem(r,`${h}${JSON.stringify(t)}`);let n=u.getItem(d);return null===n?n=`${r},`:-1===n.indexOf(`${r},`)&&(n=`${n}${r},`),u.setItem(d,n),w(e,t),!0}if(g(o)){return!s(JSON.parse(o.substring(f)),t)&&(u.setItem(r,`${h}${JSON.stringify(t,m)}`),w(e,t),!0)}return o!==t&&(u.setItem(r,`${JSON.stringify(t,m)}`),w(e,t),!0)},has(e){const t=e.split("/"),n=u.getItem(`VCS::${t[0]}`);if(!(t.length>1))return null!==n;if(!1===g(n))return!1;try{return y(JSON.parse(n.substring(f)),t),!0}catch(e){return!1}},remove(e){const t=e.split("/"),n=`VCS::${t[0]}`,r=u.getItem(n);if(null!==r)if(t.length>1){if(!0!==g(r))throw new Error(`Cannot delete property at path: "${e}" because the current value is stored as a string.`);{const o=JSON.parse(r.substring(f)),[s,i]=y(o,t);Array.isArray(s)?s.splice(parseInt(i),1):delete s[i],u.setItem(n,`${h}${JSON.stringify(o,m)}`),b(e,void 0,t,o)}}else{u.removeItem(n);const t=u.getItem(d).split(",");t.splice(t.indexOf(n),1),u.setItem(d,`${t.join(",")},`),w(e,void 0)}},clear(e=!1){const t=u.getItem(d);if(null!==t){const n=t.split(",");for(let t=0;t<n.length;t++)u.removeItem(n[t]),!1===e&&w(n[t],void 0);u.removeItem(d)}},bind(e,t){return{id:this.id,path:e,defaultValue:t}},subscribe(e,t,n={}){if("string"!=typeof e||"function"!=typeof t||null===n||"object"!=typeof n)throw new Error("Invalid arguments. Expect (path:String, handler:Function, [options:Object]");const r=Object.assign({scope:null,bubbles:!1},n,{handler:t});return c.has(e)?c.get(e).push(r):c.set(e,[r]),{unsubscribe(){const t=c.get(e);t.splice(t.indexOf(r),1),0===t.length&&c.delete(e)}}}};function g(e){for(let t=0;t<f;t++)if(e[t]!==h[t])return!1;return!0}function m(e,t){return void 0===t?null:t}function y(e,t){if(null!==e&&"object"==typeof e){let n,r;for(let o=1;o<t.length;o++)r=t[o],n=1===o?e:n[t[o-1]];if(n.hasOwnProperty(r))return[n,r];throw new Error(`Can not access store path: "${t.join("/")}". Property ".../${r}" does not exist.`)}throw new Error(`Can not access store path: "${t.join("/")}". The value stored at: "${t[0]}" is not object or array.`)}function b(e,t,n,r){let o=c.get(e);if(o&&o.length){let e,s,i,a,l=!1;for(e=0;e<o.length;e++)if(!0===o[e].bubbles){l=!0;break}if(!0===l){const t=[];let o=n[0],l=r,u=c.get(o);if(u&&u.length)for(e=0;e<u.length;e++)t.push([u[e],r]);for(e=1;e<n.length;e++)if(o+=`/${n[e]}`,l=l[n[e]],(u=c.get(o))&&u.length)for(s=0;s<u.length;s++)t.push([u[s],l]);for(e=t.length-1;e>=0;e--)(a=(i=t[e])[0]).handler.call(a.scope,i[1])}else for(e=0;e<o.length;e++)(a=o[e]).handler.call(a.scope,t)}}function w(e,t){const n=c.get(e);if(n&&n.length)for(let e,r=0;r<n.length;r++)(e=n[r]).handler.call(e.scope,t)}Object.defineProperty(p,"id",{value:Symbol("Store ID")});const C=-1,v=0,$=1,S=2,O={computedProperty:null,computedProperties:null};let P=null,N=[];class j{constructor(e,t,n=[]){this.ownPropertyName=e,this.computation=t,this.sourceProperties=n,this.intermediate=void 0,this._value=void 0,this._type=C,this.needsUpdate=!0,this.hasChanged=!1}value(e){return!0===this.needsUpdate&&(this.intermediate=this.computation.call(e,e),Array.isArray(this.intermediate)?(this.hasChanged=this._type!==$||this.intermediate.length!==this._value.length||!function(e,t){for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}(this._value,this.intermediate))&&(this._value=this.intermediate.slice(),this._type=$):"object"==typeof this.intermediate&&null!==this.intermediate?(this.hasChanged=this._type!==S||!function(e,t){const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(let o,s=0;s<n.length;s++)if(o=n[s],-1===r.indexOf(o)||e[o]!==t[o])return!1;return!0}(this._value,this.intermediate))&&(this._value=Object.assign({},this.intermediate),this._type=S):(this.hasChanged=this._value!==this.intermediate)&&(this._value=this.intermediate,this._type=v),this.needsUpdate=!1),this._value}}function I(e,t){return function(e){P=e;const t=new Map;let n;for(n of e.keys())k(n,[],t);return P=null,N=[],t}(function(e,t){Object.assign(O,{computedProperties:t});const n=new Proxy(e,{get:x});let r;for(r of t.values()){O.computedProperty=r;try{r.computation.call(n,n)}catch(e){if(e.type&&"cue-internal"===e.type)throw new Error(e.message)}}return O.computedProperty=null,O.computedProperties=null,t}(e,t))}function x(e,t){const{computedProperty:n}=O;if(!e.hasOwnProperty(t))throw{type:"cue-internal",message:`Cannot resolve computed property "${n.ownPropertyName}" because dependency "${t}" doesn't exist.`};-1===n.sourceProperties.indexOf(t)&&n.sourceProperties.push(t)}function k(e,t,n){if(P.has(e)){t.push(e),N.push(e);const r=P.get(e);for(let e,o=0;o<r.sourceProperties.length;o++){if(e=r.sourceProperties[o],-1!==t.indexOf(e))throw new Error(`Circular dependency. "${r.ownPropertyName}" is required by "${e}": ${t.join(" -> ")}`);-1===N.indexOf(e)&&k(e,t,n)}n.has(e)||n.set(e,r)}}let A=null,E=!1;const _=new Map,B=new Map,J=new Map,M=[],T={cueCallback(e,t){_.set(e,t)},cueComputations(e,t,n,r){const o=e.get(n),s=[e,t,r];for(let e=0;e<o.length;e++)B.set(o[e],s)},react(){null===A&&!1===E&&(A=requestAnimationFrame(D))}};function D(){let e,t,n,r,o,s,i,a;for(E=!0;B.size>0;){for(t of B.entries())r=t[0],-1===M.indexOf(r)&&(i=(o=t[1])[0],s=o[1],r.needsUpdate=!0,a=r.value(o[2]),!0===r.hasChanged&&(s[r.ownPropertyName]&&_.set(s[r.ownPropertyName],a),J.set(r,o)),M.push(r));for(t of(B.clear(),J.entries()))if(r=t[0],n=(o=t[1])[0].get(r.ownPropertyName))for(e=0;e<n.length;e++)B.set(n[e],o);J.clear()}for(t of _.entries())t[0](t[1]);for(_.clear();M.length>0;)M.pop();A=null,E=!1}const V="ref",z=()=>{},R=Symbol("Component Internals"),G=(()=>{const e=document.createElement("style");return e.id="cue::components",document.head.appendChild(e),e.sheet})(),L=document.createElement("style"),q={define(e,t){let n=null;const r=t.attributes?Object.keys(t.attributes):[],o=r.map(e=>t.attributes[e]),c=class extends HTMLElement{constructor(){let r,o;if(super(),null===n)for(r in n=function(e,t){const n={};n.encapsulated=!0===t.encapsulated,n.template=document.createRange().createContextualFragment(`<cue-template>${t.element.trim()}</cue-template>`).firstChild;const r=n.template.querySelectorAll(`[${V}]`);let o,s,a,l;for(n.refNames=new Map,o=0;o<r.length;o++)(s=r[o].getAttribute(V))&&s.length&&n.refNames.set(s,`[${V}="${s}"]`);if(n.styles="","string"==typeof t.styles&&t.styles.length){for(l of(n.styles=t.styles,n.refNames.entries()))n.styles=n.styles.split(l[0]).join(l[1]);if(!1===n.encapsulated){L.innerHTML=n.styles,document.head.appendChild(L);const t=L.sheet;for(o=0;o<t.rules.length;o++)0===(s=t.rules[o].selectorText).lastIndexOf(e,0)?G.insertRule(t.rules[o].cssText):0===s.lastIndexOf("self",0)?G.insertRule(t.rules[o].cssText.split("self").join(e)):G.insertRule(`${e} ${t.rules[o].cssText}`);L.innerHTML="",document.head.removeChild(L)}}const c={};if(t.reactions){const e=new Set;for(s in t.reactions){if("function"!=typeof(a=t.reactions[s]))throw new Error(`Reaction "${s}" is not a function...`);if(e.has(a))throw new Error(`Reaction "${s}" already in use. You can't use the same reaction for multiple data properties.`);c[s]=a,e.add(a)}}for(s in n.methods={},t)"initialize"!==s&&"connectedCallback"!==s&&"adoptedCallback"!==s&&"disconnectedCallback"!==s&&"function"==typeof t[s]&&(n.methods[s]=t[s]);n.initialize=i(t.initialize),n.connected=i(t.connectedCallback),n.disconnected=i(t.disconnectedCallback),n.adopted=i(t.adoptedCallback),n.data={},n.storeBindings={},n.reactions={};const u={},h=new Map;if(t.data)for(s in t.data)if(a=t.data[s],u[s]=a.value,"object"==typeof a.value&&null!==a.value&&a.value.id===p.id?n.storeBindings[s]=a.value:"function"==typeof a.value?h.set(s,new j(s,a.value)):n.data[s]=a.value,a.reaction)if("string"==typeof a.reaction){if(!c[a.reaction])throw new Error(`No Reaction with name "${a.reaction}" exists.`);n.reactions[s]=c[a.reaction]}else if("function"==typeof a.reaction){if(c[s]||n.reactions[s])throw new Error(`A reaction for data property "${s}" has already been registered.`);n.reactions[s]=a.reaction}return n.computedProperties=I(u,h),n}(e,t),c.prototype.renderEach=F,n.methods)c.prototype[r]=n.methods[r];const s=new Map,u=(h=n.data,Array.isArray(h)?l(h):a(h));var h;const f=this[R]={_data:u,data:new Proxy(u,{get(e,t){if(n.storeBindings[t])return p.get(n.storeBindings[t].path);if(s.has(t))return s.get(t).value(f.data);const r=e[t];return Array.isArray(r)?r.slice():"object"==typeof r&&null!==r?Object.assign({},r):r}}),computedProperties:s,reactions:{},subscriptions:[],refs:{},initialized:!1};for(o of n.computedProperties.entries())s.set(o[0],new j(o[1].ownPropertyName,o[1].computation,o[1].sourceProperties));for(r in f.dependencyGraph=function(e){const t=new Map;let n,r,o;for(n of e.values())for(r=0;r<n.sourceProperties.length;r++)o=n.sourceProperties[r],t.has(o)?t.get(o).push(n):t.set(o,[n]);return t}(f.computedProperties),n.reactions)f.reactions[r]=n.reactions[r].bind(null,f.refs)}connectedCallback(){const t=this[R];for(const e in n.storeBindings)t.dependencyGraph.has(e)&&t.subscriptions.push(p.subscribe(n.storeBindings[e].path,()=>{T.cueComputations(t.dependencyGraph,t.reactions,e,t.data),T.react()})),t.reactions[e]&&t.subscriptions.push(p.subscribe(n.storeBindings[e].path,n=>{T.cueCallback(t.reactions[e],n),T.react()}));if(!1===t.initialized){let r,o,s;if(!0===n.encapsulated){const e=t.shadowDom=this.attachShadow({mode:"open"});for(e.innerHTML=n.styles,r=0;r<this.childNodes.length;r++)e.appendChild(this.childNodes[r]);for(r=n.template.children.length-1;r>=0;r--)e.insertBefore(n.template.children[r].cloneNode(!0),this.firstChild)}else for(r=n.template.children.length-1;r>=0;r--)this.insertBefore(n.template.children[r].cloneNode(!0),this.firstChild);for(s in function(e,t,n){let r,o;for(r of n.entries())(o=e.querySelector(r[1]))[R]={},o.renderEach=F,t[r[0]]=o;t.self=e}(n.encapsulated?t.shadowDom:this,t.refs,n.refNames),n.storeBindings)o=n.storeBindings[s].path,p.has(o)&&t.reactions[s]?T.cueCallback(t.reactions[s],p.get(o)):n.storeBindings[s].hasOwnProperty("defaultValue")?p.set(o,n.storeBindings[s].defaultValue):console.warn(`<${e}>.data["${s}"] is bound to Store["${o}"] but Store has no value and component specifies no default.`);for(s in t.reactions)T.cueCallback(t.reactions[s],t.data[s]);T.react(),t.initialized=!0,n.initialize.call(this,t.refs)}n.connected.call(this)}disconnectedCallback(){const e=this[R].subscriptions;for(;e.length;)e.pop().unsubscribe();n.disconnected.call(this)}adoptedCallback(){n.adopted.call(this)}get(e){return this[R].data[e]}set(e,t){if(n.storeBindings[e])p.set(n.storeBindings[e].path,t);else{if(n.computedProperties.has(e))throw new Error(`You can not set property "${e}" because it is a computed property.`);{const n=this[R];s(n._data[e],t)||(n._data[e]=t,n.reactions[e]&&T.cueCallback(n.reactions[e],t),n.dependencyGraph.has(e)&&T.cueComputations(n.dependencyGraph,n.reactions,e,n.data),T.react())}}}static get observedAttributes(){return r}attributeChangedCallback(e,t,n){const s=r.indexOf(e);-1!==s&&(T.cueCallback(o[s],n,this),T.react())}};customElements.define(e,c)},create(e,t){const n="<"===(e=e.trim())[0]?document.createRange().createContextualFragment(e).firstChild:document.createElement(e);if("object"==typeof t&&null!==t)if(n[R])for(const e in t)n[R]._data.hasOwnProperty(e)?n[R]._data[e]=t[e]:console.warn(`Cannot pass data property "${e}" to component "${n.tagName}" because the property has not been explicitly defined in the components data model.`);else console.warn(`Cannot set data on element "${n.tagName}" because it has not been defined via Component.define!`);return n}};function F(e,t,n=z){e||(e=[]);const r=this[R].childData||[];if(this[R].childData=e,0===e.length)(this[R].shadowDom||this).textContent="";else if(0===r.length){const n=this[R].shadowDom||this;for(let r=0;r<e.length;r++)n.appendChild(t(e[r]))}else!function(e,t,n,r,o){let s,i,a,l=0,c=0,u=!0,h=t.length-1,f=n.length-1,d=e.firstChild,p=d,g=e.lastChild,m=g;e:for(;u;){let r;for(u=!1,s=t[l],i=n[c];s===i;){if(o(d,i),l++,c++,p=d=d.nextSibling,h<l||f<c)break e;s=t[l],i=n[c]}for(s=t[h],i=n[f];s===i;){if(o(g,i),h--,f--,a=g,m=g=g.previousSibling,h<l||f<c)break e;s=t[h],i=n[f]}for(s=t[h],i=n[c];s===i;){if(u=!0,o(g,i),r=g.previousSibling,e.insertBefore(g,p),m=g=r,c++,--h<l||f<c)break e;s=t[h],i=n[c]}for(s=t[l],i=n[f];s===i;){if(u=!0,o(d,i),r=d.nextSibling,e.insertBefore(d,a),a=m=d,d=r,f--,h<++l||f<c)break e;s=t[l],i=n[f]}}if(f<c){if(l<=h){let t;for(;l<=h;)0===h?e.removeChild(g):(t=g.previousSibling,e.removeChild(g),g=t),h--}return}if(h<l){if(c<=f)for(;c<=f;)a?e.insertBefore(r(n[c]),a):e.appendChild(r(n[c])),c++;return}const y=new Array(f+1-c),b=new Map;let w;for(w=c;w<=f;w++)y[w]=-1,b.set(n[w],w);let C=0,v=[];for(w=l;w<=h;w++)b.has(t[w])?(y[b.get(t[w])]=w,C++):v.push(w);if(0===C){for(e.textContent="",w=c;w<=f;w++)e.appendChild(r(n[w]));return}const $=function(e,t){const n=[],r=[],o=new Array(e.length);let s,i,a,l=-1;for(s=t;s<e.length;s++){if((i=e[s])<0)continue;let t,c=-1,u=n.length;if(u>0&&n[u-1]<=i)a=u-1;else{for(;u-c>1;)t=Math.floor((c+u)/2),n[t]>i?u=t:c=t;a=c}-1!==a&&(o[s]=r[a]),a===l?(n[++l]=i,r[l]=s):i<n[a+1]&&(n[a+1]=i,r[a+1]=s)}for(s=r[l];l>=0;s=o[s],l--)n[l]=s;return n}(y,c),S=[];let O=d;for(w=l;w<=h;w++)S[w]=O,O=O.nextSibling;for(w=0;w<v.length;w++)e.removeChild(S[v[w]]);let P,N=$.length-1;for(w=f;w>=c;w--)$[N]===w?(a=S[y[$[N]]],o(a,n[w]),N--):(-1===y[w]?P=r(n[w]):(P=S[y[w]],o(P,n[w])),e.insertBefore(P,a),a=P)}(this[R].shadowDom||this,r,e,t,n)}window.Cue={Server:n,Store:p,Component:q};export{q as Component,n as Server,p as Store};